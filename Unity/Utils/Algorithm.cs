using System.Collections.Generic;
using UnityEngine;
using Prota;

namespace Prota.Unity
{
    public static partial class Algorithm
    {
        
        // Generated by chatGPT, modified. 
        // 输入 polygon 是逆时针排列的顶点.
        public static void Triangulate(
            List<Vector2> polygon,
            List<int> triangles)
        {
            // Helper function to check if a vertex is an ear
            bool IsEar(List<Vector2> polygon,
                LinkedList<int> vertices,
                LinkedListNode<int> prev,
                LinkedListNode<int> cur,
                LinkedListNode<int> next)
            {
                var prevPos = polygon[prev.Value];
                var curPos = polygon[cur.Value];
                var nextPos = polygon[next.Value];
                
                // 判断这个三角是不是顺时针.
                // 是的话这个三角型是凹的, 肯定不是耳朵.
                var signedAngle = Vector2.SignedAngle(prevPos.To(curPos), curPos.To(nextPos));
                // Debug.LogError($"test index[{prevIndex},{curIndex},{nextIndex}] angle[{signedAngle}]");
                if(signedAngle < 0) return false;
                
                
                // 检查其它点是不是都在这个三角形的外面.
                foreach(var i in vertices)
                {
                    if (i == prev.Value || i == cur.Value || i == next.Value)
                        continue;
                    
                    var pos = polygon[i];
                    if (pos.PointInTriangle(curPos, nextPos, prevPos))
                        return false;
                }
                

                return true;
            }
            
            triangles.Clear();
            
            int vertexCount = polygon.Count;
            if (vertexCount < 3)
            {
                Debug.LogError("Polygon must have at least 3 vertices.");
                return;
            }

            var vertexIndex = new LinkedList<int>();
            for(int i = 0; i < vertexCount; i++) vertexIndex.AddLast(i);
            
            var curNode = vertexIndex.First;
            for(int i = 0; i < 99999; i++)
            {
                if (vertexIndex.Count < 3) break;
                
                var prevNode = curNode == vertexIndex.First ? vertexIndex.Last : curNode.Previous;
                var nextNode = curNode == vertexIndex.Last ? vertexIndex.First : curNode.Next;
                
                if (IsEar(polygon, vertexIndex, prevNode, curNode, nextNode))
                {
                    triangles.Add(prevNode.Value);
                    triangles.Add(curNode.Value);
                    triangles.Add(nextNode.Value);

                    vertexIndex.Remove(curNode);
                }
                
                curNode = nextNode;
            }
        }

    }
    
}
